// .hackerrank/fetch_stats.js
const fs = require("fs");
const https = require("https");

const USERNAME = "vsrajpurohit0666"; // <-- keep exact username
const API_URL = `https://www.hackerrank.com/rest/hackers/${USERNAME}`;
const PROFILE_URL = `https://www.hackerrank.com/${USERNAME}`;

function httpGet(url, headers = {}) {
  return new Promise((resolve, reject) => {
    const options = { headers: Object.assign({
      "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 " +
                    "(KHTML, like Gecko) Chrome/120.0 Safari/537.36",
      "Accept": "*/*"
    }, headers) };

    https.get(url, options, (res) => {
      let data = "";
      res.on("data", (c) => (data += c));
      res.on("end", () => resolve({ statusCode: res.statusCode, body: data }));
    }).on("error", (err) => reject(err));
  });
}

function safeJSON(text) {
  try { return JSON.parse(text); } catch(e) { return null; }
}

async function run() {
  console.log("Fetching HackerRank public API...");
  let apiResp = null;

  try {
    apiResp = await httpGet(API_URL, { "Accept": "application/json" });
  } catch (err) {
    console.error("API request failed:", err.message || err);
  }

  // Try to parse API JSON if we got a JSON response
  let badge = "Not found";
  let name = USERNAME;
  if (apiResp && apiResp.statusCode === 200) {
    const parsed = safeJSON(apiResp.body);
    if (parsed && parsed.model) {
      name = parsed.model.user?.name || USERNAME;
      const badges = parsed.model.badges || parsed.model.badges_summary?.badges || [];
      if (badges && badges.length) {
        const b = badges[0];
        badge = `${b.name} (${b.stars || "â­"})`;
      }
    }
  } else {
    console.log("API unavailable or blocked â€” falling back to scraping public profile page.");
    // Scrape the public profile page as fallback
    try {
      const prof = await httpGet(PROFILE_URL);
      const html = prof.body || "";
      // Try to find a badge name
      const badgeMatch = html.match(/"badge_name"\s*:\s*"([^"]+)"/i) || html.match(/class=".*?badge.*?">([^<]+)</i);
      if (badgeMatch) badge = badgeMatch[1].trim();
      // Try to extract hackos from embedded JSON or analytics attributes
      let hackos = "Not visible";
      let m1 = html.match(/"hackos"\s*:\s*(\d+)/i);
      if (m1) hackos = m1[1];
      let m2 = html.match(/data-analytics=['"]\{[^}]*"hackos"\s*:\s*(\d+)/i);
      if (m2) hackos = m2[1];
      // fallback loose search
      if (hackos === "Not visible") {
        const loose = html.match(/Hackos[:\s]*<\/.*?>\s*(\d{2,4})/i) || html.match(/"hackos"\s*:\s*"(\d{2,4})"/i);
        if (loose) hackos = loose[1];
      }

      // Build markdown block
      const mdBlock = `### ğŸŸ© HackerRank â€” Live Stats (Auto Updated)
**ğŸ‘¤ ${name}**  
**ğŸ’° Hackos:** ${hackos}  
**ğŸ… Top Badge:** ${badge}

_This section is auto-generated by GitHub Actions (updates every 6 hours)._
`;
      // Save a backup file (optional)
      fs.writeFileSync("HACKERRANK_STATS.md", mdBlock);
      // Replace in README between markers
      replaceInReadme(mdBlock);
      console.log("Scrape fallback: updated README content.");
      return;
    } catch (err) {
      console.error("Scrape failed:", err.message || err);
    }
  }

  // If API succeeded or we have badge via API
  const md = `### ğŸŸ© HackerRank â€” Live Stats (Auto Updated)
**ğŸ‘¤ ${name}**  
**ğŸ’° Hackos:** Not available (HackerRank blocks this)  
**ğŸ… Top Badge:** ${badge}

_This section is auto-generated by GitHub Actions (updates every 6 hours)._
`;
  fs.writeFileSync("HACKERRANK_STATS.md", md);
  replaceInReadme(md);
  console.log("API mode: updated README content.");
}

function replaceInReadme(mdContent) {
  const readmePath = "README.md";
  let readme = "";
  try { readme = fs.readFileSync(readmePath, "utf8"); } catch (e) { readme = `# My Repo\n\n`; }

  const start = "<!-- HACKERRANK-START -->";
  const end = "<!-- HACKERRANK-END -->";

  if (!readme.includes(start) || !readme.includes(end)) {
    // Append markers at end if not present
    readme += `\n\n## ğŸŸ© HackerRank â€” Live Stats (Auto Updated)\n${start}\n${mdContent}\n${end}\n`;
  } else {
    const before = readme.split(start)[0];
    const after = readme.split(end).slice(1).join(end);
    readme = `${before}${start}\n${mdContent}\n${end}${after}`;
  }

  fs.writeFileSync(readmePath, readme, "utf8");
}

run().catch((e)=>{ console.error("Fatal:", e); process.exit(0); });
